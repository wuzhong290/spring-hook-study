成员内部类可以访问外部类所有的变量和方法，包括静态和实例，私有和非私有。
和静态内部类不同的是，
每一个成员内部类的实例都依赖一个外部类的实例。
其它类使用内部类必须要先创建一个外部类的实例。
Out out = new Out();
Out.Inner inner = out.new Inner();
inner.print();

成员内部类不能定义静态方法和变量（final修饰的除外）。
这是因为成员内部类是非静态的，
类初始化的时候先初始化静态成员，
如果允许成员内部类定义静态变量，
那么成员内部类的静态变量初始化顺序是有歧义的。
要加载该内部类（成员内部类），
必须等到外部类Outer实例化之后（也就是有创建一个外部类对象），
JVM才能加载其内部类Inner的字节码!
java中变量的初始化顺序为：（静态变量、静态初始化块）>（变量、初始化块）>构造器
因为JVM要求所有的静态常量必须在类对象创建之前完成初始化

可以含有static final修饰的编译期变量,JVM会马上把程序中的所有编译期常量（即j）都初始化并放入常量池中，JVM会维护着这个常量池。
总的来说，常量池使得final变量的初始化脱离了外部类实例化这个条件，编译期便可以确定final常量的值。即加载常量时不需要加载类~